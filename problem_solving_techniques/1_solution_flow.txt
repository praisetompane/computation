flow: (Mcdowell, 2015:62)
    1. Read/Listen
    2. Create example
    3. Find/Create solution:
        see: 0_theory_of_computation/4_design_and_analysis_of_algorithms/0_design_and_analysis_of_algorithms.txt
    4. Test
        - base cases
        - general cases
        - error cases
    5. Optimize
        - BUD system
            - B = Bottlenecks
            - U = Unnecessary Work
            - D = Duplicated Work
    6. Test
        - same cases as step 4
    7. Walk through
    8. Implement
        7.1 Optimize for language/tools specific advantages
    9. Test
        - same cases as step 4

when confronted with a problem that seems computationally difficulty (Sipser, 2012:2):
    Option 1: Understand which aspect(s) of the problem are the root of the difficulty
                Attempt to rephrase them in a way that is easily solvable
    Option 2: You may be able to settle for a less than perfect solution to the problem
    Option 3: Some problems are only hard at the worst case and easy for all other cases.
                Determine if yours is one of these.
                    Is it fine if it runs fast most of the time and slow once in a while?
    Option 4: Consider other types of computation, that might speed up certain tasks/aspects.
        e.g. random computation.

References:
    - McDowell G.L. 2015. Cracking The Coding Interview. 6th ed. CareerCup.
    - Sipser, M. 2013. Introduction to the Theory of Computation. 3rd edition. Cengage Learning.
    - Demaine, E., Ku, J., Solomon, J. 2020. Algorithms and Computation, 6.006 - Introduction to Algorithms. Massachusetts Institute of Technology.

