Python programs are read by a parser
    the parser accepts a stream of tokens as input (Python Software Foundation, 2023).

Lexical analyzer: generates stream of tokens from Python program text (Python Software Foundation, 2023)
    for the parser.

Python program text is read as Unicode code points.
    SyntaxError is raised if file cannot be decoded (Python Software Foundation, 2023).
    def SyntaxError: https://docs.python.org/3.11/library/exceptions.html#SyntaxError

def: python lexical analysis(Python Software Foundation, 2023):
    - line structure:
        Python programs are divided into logical lines.
        see for details: src/1_lexical_analysis/1_line_structure 
        
    - identifiers and keywords
    - literals
    - operators
    - delimiters
    - other tokens      

def tokens(Python Software Foundation, 2023):

    categories:
        Q: categories = token names in the form <token_name, identifier> generated by the lexer?
        - NEWLINE
        - INDENT
        - DEDENT
        - identifiers (names)
        - keywords
        - literals
        - operators
        - delimiters

        - identifiers (names):
            - properties
                - Python 2.x:
                    valid characters to use in identifier: 
                        ASCII range
                            - A to Z 
                            - a to z
                            - _ (underscore)
                            - 0 to 9, but NOT as the first character of the identifier.
                - Python 3.x
                    - all Python 2.x valid characters
                    - non-ASCII characters as defined here:
                        https://peps.python.org/pep-3131/
            
                - unlimited length
                - case is significant
                - ALL characters are converted to Unicode Normalization form NFKC during parsing:
                    - this form is used for comparisons.

            reserved classes of identifiers:
                - identifiers besides keywords that have special meaning.
                    - they are denoted by a pattern of leading or trailing underscores.
                - classes:
                    - _* : stipulates do no import during "from module_x import *"
                    - _ :
                        - wildcard in case statement in pattern match context.
                        - convention (not enforced by Python)
                            - unused variables
                            - "special" values
                            - internationalization
                            - private class members
                        - in REPL, stored last result

                    - __*__ : used for system-defined names ("dunder" names).
                                - defined by interpreter and its implementation; including the Standard Library.
                                - ANY usage of __*__ names in an undocumented manner is subject to be broken without warning.

                    - __* : private class members
                                - through name mangling are renamed to using patter : classname__*
                                    example:
                                        class Parent:
                                            def __init__(self, values):
                                                self.items = values
                                                self.__update(values) # notice this uses the __update copy
                                        
                                            def update(self, values):
                                                for v in values
                                                    self.items.append(v)
                                            
                                            def __update = update # copy the update definition to allow subclass overriding
                                                                  # but retain Parent definition

                                        class Child(Parent):
                                            # This override is renamed to Child__update
                                            # âˆ´ does not break Parent.__init__ which requires this "def update(self, values):"

                                            def update(self, values, some_modifier):
                                                for v in values:
                                                    self.items.append(v + some_modifier)
                                                    

                                - this is to help prevent name overriding in class hierarchies

        - keywords:
            defined in: https://github.com/python/cpython/blob/a5f244d627a6815cf2d8ccec836b9b52eb3e8de2/Grammar/python.gram

            types:
                - 'hard'
                - soft
            
                - 'hard':    
                    - identifiers used as reserved words of the language.
                    - CANNOT be used as identifiers.
                
                - soft:
                    - from version 3.10
                    - identifiers used as keywords under specific contexts.
                    - for pattern matching context:
                            - match
                            - case
                            - _
        - literals:
        - operators:
        - delimiters:

    whitespace characters are NOT tokens:
        - exceptions
            - NEWLINE (\n)
            - end-of-line sequence
                - linefeed (LF)
                - return (CR)
                - return linefeed (CR LF)
        - they delineate tokens

    ambiguity resolution rule:
        the longest string of characters
        from left to right
            that form a valid token
                is the token extracted from the program text.


References:
    Python Software Foundation. 2023. Lexical analysis. https://docs.python.org/3.11/reference/lexical_analysis.html#.