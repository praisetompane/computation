What is a functor?
    resources:
        https://hackernoon.com/functors-and-applicatives-b9af535b1440
        https://www.youtube.com/watch?v=2b5ln_xQe04

    Wrapper/Container/Context for values
        with the following operations
            identity: Unit in Scala, return in Haskell
                
                unit[A](a: A): F[A]
            map
                Provides a way to apply a function to the values
                Returns values in same context(same container, this allows for chaining)
                fMap in Haskell, just map in Scala

                map[A, B](f:F[A])(f: A → B): F[B]

    Bit of Category Theory
        Functor is a "mapping" between categories
            hence the map function on all Functors
            The map function maps morphims
            identity maps the objects
    example
    Functor {
        values //the values
        map(g) // function f that applies function g to every item in values
    }

Functor laws
    given m is a Functor instance
        holding some value of type Int
        function f and g are single parameter functions that transform that value
            They have the signature: Int => Something

            VERY IMPORTANT: f and g are single parameter functions
                            This is a limitation, we can't even solve it with currying because the result type 
                            is the partially applied function wrapped in a Functor context(refers to Functors.scala) file

                            map does not know how to apply functions like these(Applicatives solve this problem)

        1. identity law
            map id = id //math "="
            Scala : m.map(identity) == m

            //given some value simply return that value
        2. distributive law
            F map f map g = F map (g◦f) //math "="
            Scala m.map(f).map(g) == m.map(x => g(f(x)))

            ◦ = standard mathematical notation for function composition 
                (g◦f) means g after f
            F = functor

What is a applicative(applicative functor)?
    Note: Address the problem that map does not know how to apply functions wrapped inside a Functor context
    A Functor that has multi-parameter functions to map over it's values

    has the following functions
        identity
        apply
            apply[A,B](f: F[A])(f: F[A → B]): F[B]

    other way to define an applicative functor
        identity
        map2

    other way to define an applicative functor
        identity
        map
        product
    laws
        https://en.wikibooks.org/wiki/Haskell/Applicative_functors#Applicative_functor_laws

    When is useful?
        Suppose you read 3 points of triangle from a DB
            returned as Future[Int] (because it's IO)
        And you want to calculate the perimeter using the function below
            def calculate(a: Int, b: Int, c: Int): Int = a + b + c

            You can't use pass them in because they're Future[Int] and the function expects Int

        solution
            def calculate(a: Int)(b: Int)(c: Int): Int = a + b + c // must be curried

        val a = Future(2)
        val b = Future(6)
        val c = Future(4)

        a.apply(b.apply(c.apply(unit(calculate))))

        Note: calculate is wrapped in unit, because apply operates on functions wrapped in a Functor context

What is a monad?
    resources: https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534
    Wrapper/Container/Context for values 
        with the following operations
            identity (return in Haskell, unit in Scala)
            bind(>>= in Haskell, flatMap in Scala)

What are the monad axioms?

What Scala data types are, or behave like, monads?

What are the basic and optional requirement/s to conform a Monad?

Explain higher order functions.

What is gained from using immutable objects?

What is tail recursion?

How does it differentiate from common recursion?

What issues are there with tail recursive functions in the JVM?

How does the Scala compiler optimize a tail recursive function?

How do you ensure that the compiler optimizes the tail recursive function?

What is function currying?  
    Taking a function of n parameters
        and turning it into n single parameter functions

    def f(x: Int)(y: Int)(z: Int) = x + y + z

    f(1) returns g(y: Int)(z: Int) = 1 + y + z
    g(5) returns h(z: Int) = 1 + 5 + z
    h(10) returns 16 // 1 + 5 + 10

What are implicit parameters?

What are typeclasses?

What are lenses?

What is and which are the uses of: Enumerators, Enumeratees and Iteratee

What is the benefit of functional data structures?